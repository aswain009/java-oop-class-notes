## Compare and contrast iterative versus sequential software lifecycle approaches.
- steps in SDLC: requirements analysis, development, testing, production, maintanance
- waterfall model
    - phases
        - requirements analysis: what should the product do?
        - design
            - what are the business rules?
            - user stories are written at this point
        - development
            - what technologies will it use?
            - what software design patterns?
            - actual coding!
        - testing
            - unit testing
            - integration testing (how all the modules work together)
            - user testing (how long does it take user to complete tasks?)
            - regression testing
                - white box testing: testing the code while knowing about the code and how it works (unit testing)
                - black box testing: testing the code as a user would use it, not knowing about how the code is working
        - production
        - maintenance
            - change requests
            - bug reports
            - software spends most of its time here
    - disadvantages
        - costly to fix bugs
        - slow
        - not flexible
        - produces software that isn't actually what the user wants
- spiral (scrum, agile) model
    - uses short sprints
    - each sprint goes through all the steps of SDLC
    - adaptable to change
    - build products incrementally
    - gets user feedback regularly
    - disadvantages
        - complex process
        - dificult to estimate
        - not easy for project managers

## Use CRC cards to capture the responsibilities of each class and the relationships between classes.


## Use UML class diagrams to illustrate relationships between classes.


## Use primitive operation counts and deductive reasoning to determine the efficiency of algorithms.


## Given a set of initial conditions, predict how the runtime of an algorithm is affected by increased input size

